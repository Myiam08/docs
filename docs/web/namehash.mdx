{/** @type {import('@/lib/mdxPageProps').MdxMetaProps} */}
export const meta = {
    description: 'All about hashing ENS names',
    contributors: ['gregskril.eth']
};

# Namehash

Many ENS operations expect a `node` input. This is a hex-encoded 32-byte value that is derived from the name using the `namehash` algorithm defined in [ENSIP-1](/ensip/1).

Namehash is a recursive algorithm that hashes each part of the name, then hashes the results together. Beacuse recursive functions aren't very efficient in Solidity, it's usually best to derive the namehash offchain and pass to it a contract. Luckily, there are libraries that do this for us.

<CodeGroup title="Namehash">
```tsx {{ title: 'Viem (TS)', language: 'ts', variant: 'viem', link: 'https://viem.sh/docs/ens/utilities/namehash' }}
import { namehash } from "viem/ens";

const node = namehash("name.eth");
// 0x95419af60496b899715eddd4a23fed7213b7c9606bb9f1bfbde17dfd6a148f02
```

```ts {{ title: 'Ethers.js (TS)', variant: 'ethers-v6', link: 'https://docs.ethers.org/v6/api/hashing/#namehash' }}
import { utils } from 'ethers'

const node = utils.namehash('name.eth')
// 0x95419af60496b899715eddd4a23fed7213b7c9606bb9f1bfbde17dfd6a148f02
```

```python {{ title: "ens-namehash-py", variant: 'python', link: 'https://github.com/ConsenSysMesh/ens-namehash-py' }}
from namehash import namehash

node = namehash('name.eth')
```

```rust {{ title: "namehash-rust", link: "https://github.com/InstateDev/namehash-rust" }}
fn main() {
  let node = &namehash("name.eth");
  let s = hex::encode(&node);
}
```

```solidity {{ title: 'Solidity', variant: 'solidity' }}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol";

contract MyContract {
    function namehash(string calldata name) public pure returns (bytes32) {
        (, bytes32 node) = NameEncoder.dnsEncodeName(name);
        return node;
    }
}
```
</CodeGroup>

<Note>
Before hashing a name, it must be normalized. Learn more in [Name Processing](/resolution/names).
</Note>

## Labelhash

Labelhash is the hash of a single label (e.g. `name` in `name.eth`), used in places that don't require the full name.

One example of where labelhash is used is in the [BaseRegistar](/registry/eth), since it only supports registering 2LDs (second-level domains, like `name.eth`) and not 3LDs+ (e.g. `sub.name.eth`). The token ID of a second-level .eth name in the BaseRegistar is the uint256 of the labelhash.

<CodeGroup title="Labelhash">
```tsx {{ title: 'Viem (TS)', language: 'ts', variant: 'viem', link: 'https://viem.sh/docs/ens/utilities/labelhash' }}
import { labelhash } from "viem/ens";

const hash = labelhash("name");
// 0x2361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60
```

```ts {{ title: 'Solidity', variant: 'solidity' }}
string constant label = "name";
bytes32 constant labelHash = keccak256(bytes(label));
// 0x2361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60
```
</CodeGroup>
